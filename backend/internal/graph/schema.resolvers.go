package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"strconv"

	"github.com/smith-dallin/manager-dashboard/internal/middleware"
	"github.com/smith-dallin/manager-dashboard/internal/models"
	"github.com/smith-dallin/manager-dashboard/internal/services"
)

// Supervisor is the resolver for the supervisor field.
// Uses dataloader to batch supervisor queries and prevent N+1 problem
func (r *employeeResolver) Supervisor(ctx context.Context, obj *Employee) (*Employee, error) {
	if obj.SupervisorID == nil {
		return nil, nil
	}

	supervisorID, err := strconv.ParseInt(*obj.SupervisorID, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid supervisor ID: %w", err)
	}

	// Use dataloader for batched loading (falls back to direct query if loaders not in context)
	user, err := GetSupervisor(ctx, r.UserRepo, supervisorID)
	if err != nil {
		return nil, err
	}

	return userToEmployee(user), nil
}

// DirectReports is the resolver for the direct_reports field.
func (r *employeeResolver) DirectReports(ctx context.Context, obj *Employee) ([]*Employee, error) {
	employeeID, err := strconv.ParseInt(obj.ID, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid employee ID: %w", err)
	}

	users, err := r.UserRepo.GetDirectReportsBySupervisorID(ctx, employeeID)
	if err != nil {
		return nil, err
	}

	employees := make([]*Employee, len(users))
	for i, u := range users {
		employees[i] = userToEmployee(&u)
	}

	return employees, nil
}

// CreateEmployee is the resolver for the createEmployee field.
func (r *mutationResolver) CreateEmployee(ctx context.Context, input CreateEmployeeInput) (*Employee, error) {
	// Check authorization - only supervisors and admins can create employees
	currentUser := middleware.GetUserFromContext(ctx)
	if currentUser == nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if currentUser.Role != models.RoleSupervisor && currentUser.Role != models.RoleAdmin {
		return nil, fmt.Errorf("forbidden: only supervisors and admins can create employees")
	}

	// Convert supervisor ID from string to int64
	var supervisorID *int64
	if input.SupervisorID != nil {
		id, err := strconv.ParseInt(*input.SupervisorID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid supervisor ID: %w", err)
		}
		supervisorID = &id
	} else {
		// Default to current user as supervisor
		supervisorID = &currentUser.ID
	}

	// Convert squad IDs from string to int64
	var squadIDs []int64
	for _, squadIDStr := range input.SquadIDs {
		squadID, err := strconv.ParseInt(squadIDStr, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid squad ID %s: %w", squadIDStr, err)
		}
		squadIDs = append(squadIDs, squadID)
	}

	// Delegate to EmployeeService for the actual creation
	serviceInput := services.CreateEmployeeInput{
		Email:        input.Email,
		FirstName:    input.FirstName,
		LastName:     input.LastName,
		Role:         models.Role(input.Role),
		Department:   input.Department,
		AvatarURL:    input.AvatarURL,
		SupervisorID: supervisorID,
		SquadIDs:     squadIDs,
	}

	result, err := r.EmployeeService.CreateEmployee(ctx, serviceInput)
	if err != nil {
		return nil, err
	}

	return userToEmployee(result.User), nil
}

// UpdateEmployee is the resolver for the updateEmployee field.
func (r *mutationResolver) UpdateEmployee(ctx context.Context, id string, input UpdateEmployeeInput) (*Employee, error) {
	// Check authorization
	currentUser := middleware.GetUserFromContext(ctx)
	if currentUser == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	employeeID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid employee ID: %w", err)
	}

	// Get the target user
	targetUser, err := r.UserRepo.GetByID(ctx, employeeID)
	if err != nil {
		return nil, fmt.Errorf("employee not found: %w", err)
	}

	// Check permissions
	if currentUser.Role == models.RoleEmployee && currentUser.ID != employeeID {
		return nil, fmt.Errorf("forbidden: employees can only update themselves")
	}

	if currentUser.Role == models.RoleSupervisor &&
		targetUser.SupervisorID != nil &&
		*targetUser.SupervisorID != currentUser.ID &&
		targetUser.ID != currentUser.ID {
		return nil, fmt.Errorf("forbidden: can only update your direct reports")
	}

	// Convert input to UpdateUserRequest
	var role *models.Role
	if input.Role != nil {
		r := models.Role(*input.Role)
		role = &r
	}

	var supervisorID *int64
	if input.SupervisorID != nil {
		id, err := strconv.ParseInt(*input.SupervisorID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid supervisor ID: %w", err)
		}
		supervisorID = &id
	}

	// Convert squad IDs from string to int64
	var squadIDs []int64
	for _, squadIDStr := range input.SquadIDs {
		squadID, err := strconv.ParseInt(squadIDStr, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid squad ID %s: %w", squadIDStr, err)
		}
		squadIDs = append(squadIDs, squadID)
	}

	req := &models.UpdateUserRequest{
		FirstName:    input.FirstName,
		LastName:     input.LastName,
		Role:         role,
		Department:   input.Department,
		AvatarURL:    input.AvatarURL,
		SupervisorID: supervisorID,
		SquadIDs:     squadIDs,
	}

	user, err := r.UserRepo.Update(ctx, employeeID, req)
	if err != nil {
		return nil, fmt.Errorf("failed to update employee: %w", err)
	}

	return userToEmployee(user), nil
}

// DeleteEmployee is the resolver for the deleteEmployee field.
func (r *mutationResolver) DeleteEmployee(ctx context.Context, id string) (bool, error) {
	// Check authorization - only supervisors can delete employees
	currentUser := middleware.GetUserFromContext(ctx)
	if currentUser == nil {
		return false, fmt.Errorf("unauthorized")
	}
	if currentUser.Role != models.RoleSupervisor {
		return false, fmt.Errorf("forbidden: only supervisors can delete employees")
	}

	employeeID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return false, fmt.Errorf("invalid employee ID: %w", err)
	}

	// Get the target user to check permissions
	targetUser, err := r.UserRepo.GetByID(ctx, employeeID)
	if err != nil {
		return false, fmt.Errorf("employee not found: %w", err)
	}

	// Check if the target is a direct report of this supervisor
	if targetUser.SupervisorID == nil || *targetUser.SupervisorID != currentUser.ID {
		return false, fmt.Errorf("forbidden: can only delete your own direct reports")
	}

	if err := r.UserRepo.Delete(ctx, employeeID); err != nil {
		return false, fmt.Errorf("failed to delete employee: %w", err)
	}

	return true, nil
}

// Employees is the resolver for the employees field.
func (r *queryResolver) Employees(ctx context.Context) ([]*Employee, error) {
	currentUser := middleware.GetUserFromContext(ctx)
	if currentUser == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	var users []models.User
	var err error

	if currentUser.Role == models.RoleSupervisor {
		// Supervisors see their direct reports
		users, err = r.UserRepo.GetDirectReportsBySupervisorID(ctx, currentUser.ID)
	} else {
		// Employees only see themselves
		users = []models.User{*currentUser}
	}

	if err != nil {
		return nil, fmt.Errorf("failed to fetch employees: %w", err)
	}

	employees := make([]*Employee, len(users))
	for i, u := range users {
		employees[i] = userToEmployee(&u)
	}

	return employees, nil
}

// Employee is the resolver for the employee field.
func (r *queryResolver) Employee(ctx context.Context, id string) (*Employee, error) {
	currentUser := middleware.GetUserFromContext(ctx)
	if currentUser == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	employeeID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid employee ID: %w", err)
	}

	// Employees can only view themselves
	if currentUser.Role == models.RoleEmployee && currentUser.ID != employeeID {
		return nil, fmt.Errorf("forbidden")
	}

	user, err := r.UserRepo.GetByID(ctx, employeeID)
	if err != nil {
		return nil, fmt.Errorf("employee not found: %w", err)
	}

	// Supervisors can only view their own direct reports
	if currentUser.Role == models.RoleSupervisor &&
		user.SupervisorID != nil &&
		*user.SupervisorID != currentUser.ID &&
		user.ID != currentUser.ID {
		return nil, fmt.Errorf("forbidden")
	}

	return userToEmployee(user), nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*Employee, error) {
	currentUser := middleware.GetUserFromContext(ctx)
	if currentUser == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	return userToEmployee(currentUser), nil
}

// Employee returns EmployeeResolver implementation.
func (r *Resolver) Employee() EmployeeResolver { return &employeeResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type employeeResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
