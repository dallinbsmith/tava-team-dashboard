package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"log"
	"strconv"

	"github.com/smith-dallin/manager-dashboard/internal/auth0"
	"github.com/smith-dallin/manager-dashboard/internal/jira"
	"github.com/smith-dallin/manager-dashboard/internal/middleware"
	"github.com/smith-dallin/manager-dashboard/internal/models"
)

// Supervisor is the resolver for the supervisor field.
func (r *employeeResolver) Supervisor(ctx context.Context, obj *Employee) (*Employee, error) {
	if obj.SupervisorID == nil {
		return nil, nil
	}

	supervisorID, err := strconv.ParseInt(*obj.SupervisorID, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid supervisor ID: %w", err)
	}

	user, err := r.UserRepo.GetByID(ctx, supervisorID)
	if err != nil {
		return nil, err
	}

	return userToEmployee(user), nil
}

// DirectReports is the resolver for the direct_reports field.
func (r *employeeResolver) DirectReports(ctx context.Context, obj *Employee) ([]*Employee, error) {
	employeeID, err := strconv.ParseInt(obj.ID, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid employee ID: %w", err)
	}

	users, err := r.UserRepo.GetDirectReportsBySupervisorID(ctx, employeeID)
	if err != nil {
		return nil, err
	}

	employees := make([]*Employee, len(users))
	for i, u := range users {
		employees[i] = userToEmployee(&u)
	}

	return employees, nil
}

// CreateEmployee is the resolver for the createEmployee field.
func (r *mutationResolver) CreateEmployee(ctx context.Context, input CreateEmployeeInput) (*Employee, error) {
	// Check authorization - only supervisors and admins can create employees
	currentUser := middleware.GetUserFromContext(ctx)
	if currentUser == nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if currentUser.Role != models.RoleSupervisor && currentUser.Role != models.RoleAdmin {
		return nil, fmt.Errorf("forbidden: only supervisors and admins can create employees")
	}

	// Convert input to CreateUserRequest
	var supervisorID *int64
	if input.SupervisorID != nil {
		id, err := strconv.ParseInt(*input.SupervisorID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid supervisor ID: %w", err)
		}
		supervisorID = &id
	} else {
		// Default to current user as supervisor
		supervisorID = &currentUser.ID
	}

	var auth0UserID string
	var jiraAccountID string

	// If Auth0 Management API is configured, create user in Auth0 first
	if r.Auth0Client != nil {
		// Generate a secure temporary password
		tempPassword, err := auth0.GenerateSecurePassword(16)
		if err != nil {
			return nil, fmt.Errorf("failed to generate temporary password: %w", err)
		}

		// Create user in Auth0
		auth0User, err := r.Auth0Client.CreateUser(ctx, input.Email, input.FirstName, input.LastName, tempPassword)
		if err != nil {
			return nil, fmt.Errorf("failed to create user in Auth0: %w", err)
		}
		auth0UserID = auth0User.UserID

		// Create a password change ticket so the user can set their own password
		// The ticket is valid for 7 days (604800 seconds)
		resultURL := r.FrontendURL + "/login"
		ticket, err := r.Auth0Client.CreatePasswordChangeTicket(ctx, auth0UserID, resultURL, 604800)
		if err != nil {
			// Log the error but don't fail - user can still use "forgot password" flow
			log.Printf("Warning: Failed to create password change ticket for user %s: %v", auth0UserID, err)
		} else {
			// TODO: Send this ticket URL to the user via email
			// For now, just log it (in production, you'd send an email)
			log.Printf("Password reset ticket created for new employee %s: %s", input.Email, ticket.Ticket)
		}
	} else {
		// Auth0 not configured - generate a unique placeholder auth0_id
		// This allows employees to be created without Auth0 integration
		randomBytes := make([]byte, 16)
		if _, err := rand.Read(randomBytes); err != nil {
			return nil, fmt.Errorf("failed to generate unique ID: %w", err)
		}
		auth0UserID = fmt.Sprintf("placeholder|%s", hex.EncodeToString(randomBytes))
		log.Printf("Auth0 not configured - created placeholder auth0_id for %s", input.Email)
	}

	// If organization has Jira OAuth configured, create user in Jira
	if r.OrgJiraRepo != nil {
		orgJiraSettings, err := r.OrgJiraRepo.Get(ctx)
		if err != nil {
			log.Printf("Warning: Failed to get org Jira settings: %v", err)
		} else if orgJiraSettings != nil {
			// Create Jira client with org OAuth credentials
			jiraClient := jira.NewOAuthClient(
				orgJiraSettings.OAuthAccessToken,
				orgJiraSettings.CloudID,
				orgJiraSettings.SiteURL,
			)

			// Create user in Jira
			displayName := fmt.Sprintf("%s %s", input.FirstName, input.LastName)
			jiraUser, err := jiraClient.CreateUser(input.Email, displayName)
			if err != nil {
				// Log the error but don't fail - Jira user creation is optional
				log.Printf("Warning: Failed to create Jira user for %s: %v", input.Email, err)
			} else {
				jiraAccountID = jiraUser.AccountID
				log.Printf("Jira user created for new employee %s with account ID: %s", input.Email, jiraAccountID)
			}
		}
	}

	// Convert squad IDs from string to int64
	var squadIDs []int64
	for _, squadIDStr := range input.SquadIDs {
		squadID, err := strconv.ParseInt(squadIDStr, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid squad ID %s: %w", squadIDStr, err)
		}
		squadIDs = append(squadIDs, squadID)
	}

	req := &models.CreateUserRequest{
		Email:        input.Email,
		FirstName:    input.FirstName,
		LastName:     input.LastName,
		Role:         models.Role(input.Role),
		Department:   input.Department,
		AvatarURL:    input.AvatarURL,
		SupervisorID: supervisorID,
		SquadIDs:     squadIDs,
	}

	user, err := r.UserRepo.Create(ctx, req, auth0UserID)
	if err != nil {
		// If we created a user in Auth0 but failed to create in DB, we should clean up
		if auth0UserID != "" && r.Auth0Client != nil {
			if deleteErr := r.Auth0Client.DeleteUser(ctx, auth0UserID); deleteErr != nil {
				log.Printf("Warning: Failed to delete Auth0 user %s after DB creation failure: %v", auth0UserID, deleteErr)
			}
		}
		return nil, fmt.Errorf("failed to create employee: %w", err)
	}

	// If Jira user was created, update the user with the Jira account ID mapping
	if jiraAccountID != "" {
		if err := r.UserRepo.UpdateJiraAccountID(ctx, user.ID, &jiraAccountID); err != nil {
			log.Printf("Warning: Failed to save Jira account ID mapping for user %d: %v", user.ID, err)
		} else {
			user.JiraAccountID = &jiraAccountID
		}
	}

	// Assign squads to the user
	if len(squadIDs) > 0 && r.SquadRepo != nil {
		if err := r.SquadRepo.SetUserSquads(ctx, user.ID, squadIDs); err != nil {
			log.Printf("Warning: Failed to assign squads to user %d: %v", user.ID, err)
		} else {
			// Load the squads into the user object for the response
			squads, err := r.SquadRepo.GetByUserID(ctx, user.ID)
			if err != nil {
				log.Printf("Warning: Failed to load squads for user %d: %v", user.ID, err)
			} else {
				user.Squads = squads
			}
		}
	}

	return userToEmployee(user), nil
}

// UpdateEmployee is the resolver for the updateEmployee field.
func (r *mutationResolver) UpdateEmployee(ctx context.Context, id string, input UpdateEmployeeInput) (*Employee, error) {
	// Check authorization
	currentUser := middleware.GetUserFromContext(ctx)
	if currentUser == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	employeeID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid employee ID: %w", err)
	}

	// Get the target user
	targetUser, err := r.UserRepo.GetByID(ctx, employeeID)
	if err != nil {
		return nil, fmt.Errorf("employee not found: %w", err)
	}

	// Check permissions
	if currentUser.Role == models.RoleEmployee && currentUser.ID != employeeID {
		return nil, fmt.Errorf("forbidden: employees can only update themselves")
	}

	if currentUser.Role == models.RoleSupervisor &&
		targetUser.SupervisorID != nil &&
		*targetUser.SupervisorID != currentUser.ID &&
		targetUser.ID != currentUser.ID {
		return nil, fmt.Errorf("forbidden: can only update your direct reports")
	}

	// Convert input to UpdateUserRequest
	var role *models.Role
	if input.Role != nil {
		r := models.Role(*input.Role)
		role = &r
	}

	var supervisorID *int64
	if input.SupervisorID != nil {
		id, err := strconv.ParseInt(*input.SupervisorID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid supervisor ID: %w", err)
		}
		supervisorID = &id
	}

	// Convert squad IDs from string to int64
	var squadIDs []int64
	for _, squadIDStr := range input.SquadIDs {
		squadID, err := strconv.ParseInt(squadIDStr, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid squad ID %s: %w", squadIDStr, err)
		}
		squadIDs = append(squadIDs, squadID)
	}

	req := &models.UpdateUserRequest{
		FirstName:    input.FirstName,
		LastName:     input.LastName,
		Role:         role,
		Department:   input.Department,
		AvatarURL:    input.AvatarURL,
		SupervisorID: supervisorID,
		SquadIDs:     squadIDs,
	}

	user, err := r.UserRepo.Update(ctx, employeeID, req)
	if err != nil {
		return nil, fmt.Errorf("failed to update employee: %w", err)
	}

	return userToEmployee(user), nil
}

// DeleteEmployee is the resolver for the deleteEmployee field.
func (r *mutationResolver) DeleteEmployee(ctx context.Context, id string) (bool, error) {
	// Check authorization - only supervisors can delete employees
	currentUser := middleware.GetUserFromContext(ctx)
	if currentUser == nil {
		return false, fmt.Errorf("unauthorized")
	}
	if currentUser.Role != models.RoleSupervisor {
		return false, fmt.Errorf("forbidden: only supervisors can delete employees")
	}

	employeeID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return false, fmt.Errorf("invalid employee ID: %w", err)
	}

	// Get the target user to check permissions
	targetUser, err := r.UserRepo.GetByID(ctx, employeeID)
	if err != nil {
		return false, fmt.Errorf("employee not found: %w", err)
	}

	// Check if the target is a direct report of this supervisor
	if targetUser.SupervisorID == nil || *targetUser.SupervisorID != currentUser.ID {
		return false, fmt.Errorf("forbidden: can only delete your own direct reports")
	}

	if err := r.UserRepo.Delete(ctx, employeeID); err != nil {
		return false, fmt.Errorf("failed to delete employee: %w", err)
	}

	return true, nil
}

// Employees is the resolver for the employees field.
func (r *queryResolver) Employees(ctx context.Context) ([]*Employee, error) {
	currentUser := middleware.GetUserFromContext(ctx)
	if currentUser == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	var users []models.User
	var err error

	if currentUser.Role == models.RoleSupervisor {
		// Supervisors see their direct reports
		users, err = r.UserRepo.GetDirectReportsBySupervisorID(ctx, currentUser.ID)
	} else {
		// Employees only see themselves
		users = []models.User{*currentUser}
	}

	if err != nil {
		return nil, fmt.Errorf("failed to fetch employees: %w", err)
	}

	employees := make([]*Employee, len(users))
	for i, u := range users {
		employees[i] = userToEmployee(&u)
	}

	return employees, nil
}

// Employee is the resolver for the employee field.
func (r *queryResolver) Employee(ctx context.Context, id string) (*Employee, error) {
	currentUser := middleware.GetUserFromContext(ctx)
	if currentUser == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	employeeID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid employee ID: %w", err)
	}

	// Employees can only view themselves
	if currentUser.Role == models.RoleEmployee && currentUser.ID != employeeID {
		return nil, fmt.Errorf("forbidden")
	}

	user, err := r.UserRepo.GetByID(ctx, employeeID)
	if err != nil {
		return nil, fmt.Errorf("employee not found: %w", err)
	}

	// Supervisors can only view their own direct reports
	if currentUser.Role == models.RoleSupervisor &&
		user.SupervisorID != nil &&
		*user.SupervisorID != currentUser.ID &&
		user.ID != currentUser.ID {
		return nil, fmt.Errorf("forbidden")
	}

	return userToEmployee(user), nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*Employee, error) {
	currentUser := middleware.GetUserFromContext(ctx)
	if currentUser == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	return userToEmployee(currentUser), nil
}

// Employee returns EmployeeResolver implementation.
func (r *Resolver) Employee() EmployeeResolver { return &employeeResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type employeeResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
